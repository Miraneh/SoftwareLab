# آزمایش چهارم
مهرانه نجفی (۹۷۱۰۴۷۰۷)، رستا روغنی(۹۷۱۰۵۹۶۳) 

**مراحل انجام پروژه**  
۱- برنامه‌ای نوشتیم که با داشتن طول و عرض یک مستطیل، مساحت آن را حساب کند.

<img width="970" alt="1" src="https://user-images.githubusercontent.com/45355352/205282277-bcd98828-6720-4341-ac24-8bacc02c552d.png">

۲- برای دریافت کردن و تغییر دادن طول و عرض مستطیل به کلاس آن متدهای getter و setter اضافه کردیم.

<img width="600" alt="2" src="https://user-images.githubusercontent.com/45355352/205282756-c59a1d41-8e36-4793-8255-fec547a35c18.png">

۳- درنهایت کد را به گونه‌ای تغییر دادیم که یک کلاس مربع از کلاس مستطیل ارث‌بری کند و توابع لازم را override کند.

<img width="600" alt="3" src="https://user-images.githubusercontent.com/45355352/205283177-714eed23-6160-47c0-adab-b7b3ee3c740f.png">

۴- کدی که در مرحله‌ی قبلی نوشته‌شد، از اصول SOLID پیروی نمی‌کرد بنابراین باید در آن تغییراتی می‌دادیم:

- اصل Single responsibility principle (SRP): این اصل بطور کلی در کد ما برقرار است و می‌بینیم که هر دو کلاس مربع و مستطیل فقط یک Actor دارند و تنها از طریق کلاس main می‌توان در آن تغییر ایجاد کرد.
- اصل Open-closed principle: این اصل درابتدا برقرار نیست چرا که در کلاس مربع باید بعضی از توابع مستطیل را override می‌کردیم و اگر بخواهیم هر شکل دیگری را نیز اضافه کنیم که از مستطیل ارث می‌برد، این کار را برای آن نیز باید تکرار کنیم (درواقع کد را modify کنیم). برای برقرار کردن این اصل، همانطور که در ویدئوی آموزشی نیز گفته‌شد اصل پنجم را برقرار می‌کنیم که در ادامه درمورد آن توضیح خواهیم داد.
- اصل Liskov substitution principle: این اصل می‌گوید که ما باید بتوانیم کلاس بچه را جایگزین کلاس والد کنیم بدون این‌که رفتار غیرقابل‌ پیش‌بینی از آن دریافت کنیم. در مرحله‌ی تست کردن دیدیم زمانی‌ که مربع از کلاس مستطیل ارث‌بری می‌کند، گاها رفتاری که ما انتظار داریم را نشان نمی‌دهد. بطور مثال اگر طول و عرض یک مستطیل را به‌ترتیب به دو و سه تغییر بدهیم، مساحت آن ۶ می‌شود اما اگر همین‌کار را برای مربع انجام دهیم، مساحت آن ۹ می‌شود. یعنی با یک سناریوی یکسان، جواب‌های متفاوتی گرفتیم. همچنین کلاس مربع preconditionهای قوی‌تری از کلاس مستطیل دارد (شرط برابری طول و عرض در مربع افزون بر مستطیل است). برای حل این مشکل، کلاس مربع را به‌گونه‌ای نوشتیم که دیگر از کلاس مستطیل ارث‌بری نکند و جداگانه getter و setter و تابع محاسبه‌ی مساحت داشته‌باشد.
- اصل Interface segregation principle: این اصل می‌گوید که بهره‌بردن از چند اینترفیس کوچک و باجزئیات، بهتر از بهره‌بردن از یک اینترفیس کلی است چراکه بعضی از کلاس‌ها ممکن است نیازی به استفاده از همه‌ی فیلدها و متدهای موجود در یک اینترفیس کلی نداشته‌باشند. این مشکل در کد ما از اول وجود نداشته‌است.
- اصل Dependency inversion principle: به‌جای تکیه کردن بر پیاده‌سازی concrete، بهتر است از abstraction استفاده کنیم. به همین منظور ما هم یک interface به نام shape تعریف کردیم که متد area دارد و کلاس‌های مستطیل و مربع آن را implement می‌‌کنند و مطابق با فرمول خودشان، متد area را تعریف می‌کنند. این کار ما همچنان اصل چهارم را نقض نمی‌کند چون مساحت ویژگی‌ای است که تمامی اشکال دارند.

درنهایت پس از دادن تغییراتی که گفته‌شد، کد ما به شکل زیر درآمد:

  <img width="600" alt="4" src="https://user-images.githubusercontent.com/45355352/205327905-5cee9b76-2c30-4b8a-bf09-086b03839b07.png">
  <img width="600" alt="5" src="https://user-images.githubusercontent.com/45355352/205327961-eeeb54c3-964a-4510-ba97-4cebff969bf3.png">


**مراحل تست برنامه** 



**سوالات دستورکار**

۱. هر یک از اصول SOLID را در دو الی سه خط توضیح دهید.

۲. اصول SOLID درکدام یک از گام‌های اصلی ایجاد نرم‌افزار (تحلیل نیازمندی‌ها، طراحی، پیاده‌سازی، تست و اسقرار) استفاده می‌شوند؟ توضح دهید. 

۳. معمولا گام تست درپایان روند ایجاد نرم‌افزار انجام می‌شود، اما در روش TDD تست‌نویسی پیش از پیاده‌سازی شروع می‌شود. آیا این دو مورد با هم تناقضی دارند؟ توضیح دهید.

خیر تناقضی ندارند چراکه روش TDD یک روش برای پیاده‌سازی نرم‌افزار است و نه برای تست آن و unit-testهایی که درطول آن نوشته می‌شوند مستقل‌اند از تست‌های نهایی برای چک نرم‌افزار و هدف متفاوتی دارند. بنابراین همانطور که در عکس زیر هم مشاهده می‌کنید، در روش TDD هم بعد از خروج از مرحله‌ی implementation (یا همان development) نرم‌افزار وارد مرحله‌ی testing خواهد شد.   

![image](https://user-images.githubusercontent.com/45355352/205320489-5ca509e7-85cf-4912-af5a-ef2ee6022157.png)


۴. فرض کنید در آزمایش بالا نیازی به تغییر ابعاد مستطیل نداشتیم. در این حالت طراحی مدلها چه تفاوتی می‌کند؟

درصورتی‌که نیازی به تغییر ابعاد مستطیل نبود و می‌شد آن را immutable درنظر گرفت، دیگر در طراحی مدل‌ها نیازی به تعریف getter و setter نبود و می‌شد کد را به این‌صورت نوشت که کلاس مربع از کلاس مستطیل ارث‌بری کند. دراین حالت Liskov Substitution principle نیز برقرار خواهد بود و باگی وارد کد ما نمی‌شود چرا که دیگر حالتی پیش نمی‌آمد که بشود به تنهایی طول یا عرض مستطیل را تغییر داد (در مربع این کار قابل انجام نیست و حتما طول و عرض آن با هم تغییر می‌کنند که به همین حالت دچار باگ می‌شویم چون اگر این شرط را رعایت نکنیم شکل‌مان دیگر مربع نیست و اگر هم رعایت کنیم، برای سناریوهای یکسان شکل مربع رفتار مشابهی با مستطیل نشان نمی‌دهد ). حال اگر هم بخواهیم طول و عرض یک مستطیل را عوض کنیم، باید یک مستطیل جدید بسازیم چون هویت آن(طول و عرض) با هویت مستطیل قبلی متفاوت است. 
